---
title: "Report v.0.71"
author: "AbSolution"
date: "`r format(Sys.time())`"
output: 
  html_document:
    toc: true # table of content true
    toc_depth: 3  # upto three depths of headings (specified by #, ## and ###)
    toc_float: true
    number_sections: true  ## if you want number sections at each table header
    theme: flatly  # many options for theme, this one is my favorite.
    highlight: tango  # specifies the syntax highlighting style
    code_folding: hide
---




```{r setup, include = FALSE}
knitr::opts_chunk$set(
  out.width = "100%", 
  tidy = TRUE
)
parameters_only_for_shinymeta_info <- local(if (shiny::isRunning()) {
  return(NULL)
} else {
  author <- "Rodrigo García"
  usermail <- "r.garciavaliente@amsterdamumc.nl"
  user_0_comments <- "We will test AbSolution with a test dataset (https://alakazam.readthedocs.io/en/stable/topics/Example10x/)."
  user_1_comments <- "The nucleotide sequences in this BCR dataset include part of the sequence before the FWR1, so we remove those."
  user_2_comments <- "We calculate approximately about 12k features per sequence."
  user_3_comments <- ""
  user_4_comments <- ""
  user_5_comments <- ""
  return(list(author = author, usermail = usermail, user_0_comments = user_0_comments, user_1_comments = user_1_comments, user_2_comments = user_2_comments, user_3_comments = user_3_comments, user_4_comments = user_4_comments, user_5_comments = user_5_comments))
})
parameters_only_for_shinymeta_info
author <- parameters_only_for_shinymeta_info$author
usermail <- parameters_only_for_shinymeta_info$usermail
user_0_comments <- parameters_only_for_shinymeta_info$user_0_comments
user_1_comments <- parameters_only_for_shinymeta_info$user_1_comments
user_2_comments <- parameters_only_for_shinymeta_info$user_2_comments
user_3_comments <- parameters_only_for_shinymeta_info$user_3_comments
user_4_comments <- parameters_only_for_shinymeta_info$user_4_comments
user_5_comments <- parameters_only_for_shinymeta_info$user_5_comments
```


**AbSolution** is a tool for BCR/TCR Fab sequence feature analysis. This report was generated for reproducibility purposes.<br>
<br>
For more details on using AbSolution see <http://rmarkdown.rstudio.com>. AbSolution follows the [ENCORE guidelines](https://www.nature.com/articles/s41467-024-52446-8). <br>

Author: `r (author)`<br>
Contact email: `r (usermail)`

# Project information

User comments: `r (user_0_comments)`<br>

```{r loading_info, warning = FALSE, message = FALSE}
library(AbSolution)
library(shiny)
library(dplyr)
library(plotly)

```

Datasets and parameters:
```{r loading_parameters, warning = FALSE, message = FALSE, max.height='200px'}
sample_table_react <- local(if (is.null(NULL) && TRUE == F) {
  return(NULL)
} else {
  sample_info <- structure(list(Filename = "Example10x_alakazam", Sample = "PBMC", Patient = "HealthyDonor", Group = "CD19+", Subgroup = "", Additional_info = "10xGenomics"), class = "data.frame", row.names = c(NA, -1L))
  if (all(c("Filename", "Sample", "Patient", "Group", "Subgroup") %in% colnames(sample_info))) {
    return(sample_info)
  } else {
    error.table <- data.frame(Error = paste("Modify and reupload again. The following column(s) are missing:", paste(c("Filename", "Sample", "Patient", "Group", "Subgroup")[which(!(c("Filename", "Sample", "Patient", "Group", "Subgroup") %in% colnames(sample_info)))], collapse = ", "), sep = " "))
    return(error.table)
  }
})
sample_table_react
parameters_only_for_shinymeta <- local(if (shiny::isRunning()) {
  return(NULL)
} else {
  folder_values <- list()
  folder_values$Featured <- "//home/rgarcia/Documentos/2.Feature_determination"
  folder_values$AIRR_parsed <- "//home/rgarcia/Documentos/1.Files_parsed"
  Big_mem_values <- list()
  Big_mem_values$Run <- 3
  Selection_values <- list()
  Features_values <- list()
  Exploration_values <- list()
  Features_values <- list(Current = 0, Total = 0)
  input <- list()
  input$use_what <- "Repertoire"
  input$use_productive_or_not <- "Productive"
  input$my_regions <- "CDR3"
  input$my_var_elements <- c("NT", "AA")
  input$my_vars <- c("Length", "Composition", "NGly sites", "Hot/Cold motifs", "Peptide features")
  input$my_vartypes <- "Baseline"
  input$use_sharedVDJ <- FALSE
  input$VJ_included <- NULL
  input$groups_selected <- NULL
  input$group_A <- NULL
  input$group_B <- NULL
  input$group_C <- NULL
  input$use_univlog <- FALSE
  input$samples_selected <- "HealthyDonor__PBMC"
  input$exclude_variables <- NULL
  input$pval_type <- "Corrected by Bonferroni"
  input$pval_cutoff <- 0.05
  input$estimate_cutoff <- 2L
  input$number_selected_vars <- "All"
  input$VJ_deselected <- NULL
  input$VDJ_normalized_per_size <- TRUE
  input$Rmut_filter <- c(0L, 26L)
  input$work_as_categories <- FALSE
  input$VDJ_maximize_clones <- TRUE
  input$VDJ_normalized_per_sample <- FALSE
  input$my_clone_def <- "Clone_AA_CDR3_VCDR3J_100__simil"
  input$clonal_group <- "Clone_AA_CDR3_VCDR3J_100__simil"
  input$clonal_region_group <- "CDR3"
  input$plot_color <- "Group"
  input$plot_color_expl <- "Group"
  input$Exploration_plot_type <- "PCA"
  input$Exploration_plot_type_dim <- c("1", "2")
  input$Selection_plot_type <- "PCA"
  input$Selection_plot_type_dim <- c("1", "2")
  input$plot_feature <- "NT_CDR3_length"
  input$plot_color_feature <- NULL
  input$show_reconstructed <- FALSE
  input$hide_points <- TRUE
  input$use_UMAP <- FALSE
  input$clonal_level_groupf <- "AA"
  input$identity_clonal_group <- 100L
  input$clones <- NULL
  input$filter_clonal_group <- 0L
  input$dominance_threshold <- 0.5
  input$seed <- 1234L
  input$colorblind_mode <- FALSE
  input$new_clonal_group <- "VCDR3J"
  input$calculate_shared_clones <- FALSE
  input$preinfolder_AIRR <- list(path = list("", "home", "rgarcia", "Documentos"), root = "Computer")
  input$C_region_included_airr <- TRUE
  input$Dgene_reconstruct_airr <- TRUE
  input$TCRBCR_input_file <- "BCR"
  input$base_folder <- list(path = list("", "home", "rgarcia", "Documentos"), root = "Computer")
  input$FWR1partial_airr <- FALSE
  input$FWR4partial_airr <- FALSE
  input$raw_sample_file <- NULL
  input$include_data_report <- TRUE
  Big_mem_color_values <- list()
  sample_info_react <- list()
  sample_info_react$table <- structure(list(Filename = "Example10x_alakazam", Sample = "PBMC", Patient = "HealthyDonor", Group = "CD19+", Subgroup = "", Additional_info = "10xGenomics"), class = "data.frame", row.names = c(NA, -1L))
  sample_info_react$summary_status <- FALSE
  sample_info_react$test_status <- TRUE
  sample_info_react$step_3 <- TRUE
  ID_selected_values <- list()
  ID_selected_values$subclones <- NULL
  ID_selected_values$clones <- NULL
  ID_selected_values$intersection_samples <- NULL
  if (TRUE) {
    folder_values$Featured <- "../Data/Dataset/Processed/2.Feature_determination"
    folder_values$AIRR_parsed <- "../Data/Dataset/Processed/1.Files_parsed"
    input$base_folder <- "../Data/Dataset/Meta"
    input$preinfolder_AIRR <- "../Data/Dataset/Raw"
  }
  return(list(input = input, folder_values = folder_values, Exploration_values = Exploration_values, Selection_values = Selection_values, Big_mem_values = Big_mem_values, Big_mem_color_values = Big_mem_color_values, ID_selected_values = ID_selected_values, sample_info_react = sample_info_react, Features_values = Features_values))
})
parameters_only_for_shinymeta
input <- parameters_only_for_shinymeta$input
folder_values <- parameters_only_for_shinymeta$folder_values
Exploration_values <- parameters_only_for_shinymeta$Exploration_values
Selection_values <- parameters_only_for_shinymeta$Selection_values
Big_mem_values <- parameters_only_for_shinymeta$Big_mem_values
Big_mem_color_values <- parameters_only_for_shinymeta$Big_mem_color_values
ID_selected_values <- parameters_only_for_shinymeta$ID_selected_values
sample_info_react <- parameters_only_for_shinymeta$sample_info_react
Features_values <- parameters_only_for_shinymeta$Features_values
```

# Processing input & feature calculation

User comments: `r (user_1_comments)`<br> `r (user_2_comments)`<br>

```{r parse_input, warning = FALSE, message = FALSE, eval = FALSE}
if (shiny::isRunning()) {
  shinyjs::hide("Preprocess_AIRR", anim = TRUE)
  session$sendCustomMessage(type = "testmessage", message = "Preprocessing")
}
if (shiny::isRunning()) {
  folder_values$AIRR_parsed <- file.path(shinyFiles::parseDirPath(volumes, input$base_folder), "1.Files_parsed")
} else {
  volumes <- shinyFiles::getVolumes()
}
unlink(folder_values$AIRR_parsed, recursive = TRUE)
dir.create(folder_values$AIRR_parsed)
if (shiny::isRunning() || !(input$include_data_report)) {
  write.table(sample_info_react$table, file.path(shinyFiles::parseDirPath(volumes, input$base_folder), "Sample_summary.txt"), append = F, row.names = F, col.names = T, sep = "\t", quote = F)
} else {
  write.table(sample_info_react$table, file.path(input$base_folder, "Sample_summary.txt"), append = F, row.names = F, col.names = T, sep = "\t", quote = F)
}
if (shiny::isRunning()) {
  shinyjs::show("pb_AIRR_vis", anim = TRUE)
}
if (shiny::isRunning()) {
  inf_table <- sample_table_react()
} else {
  inf_table <- sample_info_react$table
}
print("inf_table")
print(inf_table)
for (row_number_sample_table in c(1:nrow(inf_table))) {
  print(row_number_sample_table)
  AbSolution:::parse_AIRRSeq_file(file = inf_table$Filename[row_number_sample_table], group = inf_table$Group[row_number_sample_table], patient = inf_table$Patient[row_number_sample_table], subgroup = inf_table$Subgroup[row_number_sample_table], sample = inf_table$Sample[row_number_sample_table], input_path = if (shiny::isRunning() || !(input$include_data_report)) {
    paste(shinyFiles::parseDirPath(volumes(), input$preinfolder_AIRR), "/", sep = "")
  } else {
    paste(input$preinfolder_AIRR, "/", sep = "")
  }, C_region_included = input$C_region_included_airr, FWR1partial = input$FWR1partial_airr, FWR4partial = input$FWR4partial_airr, output_path = paste(folder_values$AIRR_parsed, "/", sep = ""), D_gene = input$Dgene_reconstruct_airr, repertoire = input$TCRBCR_input_file)
  if (shiny::isRunning()) {
    shinyWidgets::updateProgressBar(session = session, id = "pb_AIRR", value = 100 * (row_number_sample_table / nrow(inf_table)), total = 100, title = paste("Process", trunc(100 * (row_number_sample_table / nrow(inf_table)) / 10)))
    Sys.sleep(0.1)
  }
}
print("Step done")
if (shiny::isRunning()) {
  shinyjs::hide("pb_AIRR_vis", anim = TRUE)
  can_show_button_to_step$step_2_AIRR <- TRUE
}
```

```{r feature_calculation, warning = FALSE, message = FALSE, eval = FALSE}
if (shiny::isRunning()) {
  hide("Feature_determination")
  session$sendCustomMessage(type = "testmessage", message = "Calculating features, be patient!")
}
if (shiny::isRunning()) {
  folder_values$Featured <- file.path(shinyFiles::parseDirPath(volumes(), input$base_folder), "2.Feature_determination")
}
unlink(folder_values$Featured, recursive = TRUE)
dir.create(folder_values$Featured)
if (shiny::isRunning()) {
  shinyjs::show("pb_Feature_vis")
}
Features_values$Total <- AbSolution:::Feature_1(if (shiny::isRunning()) {
  shinyFiles::parseDirPath(volumes, input$base_folder)
} else {
  dirname(folder_values$Featured)
}, grouping_by = c("Patient", "Group"))
print(Features_values$Total)
List_dfs <- split(data.table::as.data.table(data.table::fread(if (shiny::isRunning()) {
  file.path(paste(shinyFiles::parseDirPath(volumes, input$base_folder), "/2.Feature_determination", sep = ""), "IMGT_parsed_index_extended.txt")
} else {
  file.path(folder_values$Featured, "IMGT_parsed_index_extended.txt")
}, header = T, sep = "\t", quote = FALSE)), by = c("Patient", "Group"))
print("Feature calculation")
for (i in c(1:length(List_dfs))) {
  print(paste(i, length(List_dfs), sep = " / "))
  Features_values$Current <- Features_values$Current + 1
  AbSolution:::Feature__dataset(path_base = if (shiny::isRunning()) {
    shinyFiles::parseDirPath(volumes, input$base_folder)
  } else {
    dirname(folder_values$Featured)
  }, DF_to_parse = List_dfs[[i]], name_DF_to_parse = names(List_dfs)[i], FWR1partial = input$FWR1partial_airr, FWR4partial = input$FWR4partial_airr)
}
rm(List_dfs)
if (shiny::isRunning()) {
  hide("pb_Feature_vis")
  can_show_button_to_step$step_3 <- TRUE
}
```

```{r loading_file, warning = FALSE, message = FALSE}
if (shiny::isRunning()) {
  print("Merging")
}
info <- AbSolution:::merge_FBMs(folder_values$Featured)
if (shiny::isRunning()) {
  print("Merged")
}
Big_mem_values$Header <- info[[1]]
Big_mem_values$Short_DF <- info[[2]]
Big_mem_values$Short_DF$Patient_Sample <- paste(Big_mem_values$Short_DF$Patient, Big_mem_values$Short_DF$Sample, sep = "__")
Big_mem_values$Short_DF$Text_ID <- paste(Big_mem_values$Short_DF$ID, Big_mem_values$Short_DF$Sequence_type, sep = "_&_")
Big_mem_values$Big_DF <- info[[3]]
if (shiny::isRunning()) {
  updateSliderInput(inputId = "Rmut_filter", min = min(Big_mem_values$Big_DF[, which(Big_mem_values$Header == "AA_Whole_Replacement_muts_counts")]), max = max(Big_mem_values$Big_DF[, which(Big_mem_values$Header == "AA_Whole_Replacement_muts_counts")]))
}
Big_mem_values$Patient_Sample <- unique(Big_mem_values$Short_DF$Patient_Sample)
Big_mem_values$VJs <- sort(unique(Big_mem_values$Short_DF$V_and_J))
counts_VJs <- table(Big_mem_values$VJs) / 2
names(Big_mem_values$VJs) <- sapply(Big_mem_values$VJs, function(z) paste(z, counts_VJs[which(names(counts_VJs) == z)], sep = " - Counts:"))
rm(info)
if (any(grepl(",", Big_mem_values$Short_DF$Best_V, fixed = T))) {
  Big_mem_values$Short_DF <- Big_mem_values$Short_DF %>%
    mutate(Best_V = gsub(",.*", "", Best_V)) %>%
    mutate(Best_J = gsub(",.*", "", Best_J)) %>%
    mutate(Best_D = gsub(",.*", "", Best_D)) %>%
    mutate(V_and_J = paste0(Best_V, "_", Best_J)) %>%
    mutate(V_and_D_and_J = paste0(Best_V, "_", Best_D, "_", Best_J))
}
Big_mem_color_values$list_values <- list()
Big_mem_color_values$list_values[["V"]] <- list()
Big_mem_color_values$list_values[["D"]] <- list()
Big_mem_color_values$list_values[["J"]] <- list()
for (gene in unique(Big_mem_values$Short_DF$Best_V)) {
  Big_mem_color_values$list_values[["V"]][[strsplit(strsplit(strsplit(gene, split = "*", fixed = T)[[1]][1], split = "/")[[1]][1], split = "-")[[1]][1]]] <- sort(unique(c(Big_mem_color_values$list_values[["V"]][[strsplit(strsplit(strsplit(gene, split = "*", fixed = T)[[1]][1], split = "/")[[1]][1], split = "-")[[1]][1]]], gene)))
}
for (gene in sort(unique(Big_mem_values$Short_DF$Best_J))) {
  Big_mem_color_values$list_values[["J"]][[strsplit(strsplit(strsplit(gene, split = "*", fixed = T)[[1]][1], split = "/")[[1]][1], split = "-")[[1]][1]]] <- sort(unique(c(Big_mem_color_values$list_values[["J"]][[strsplit(strsplit(strsplit(gene, split = "*", fixed = T)[[1]][1], split = "/")[[1]][1], split = "-")[[1]][1]]], gene)))
}
if ("Best_D" %in% colnames(Big_mem_values$Short_DF)) {
  for (gene in sort(unique(Big_mem_values$Short_DF$Best_D))) {
    Big_mem_color_values$list_values[["D"]][[strsplit(strsplit(strsplit(gene, split = "*", fixed = T)[[1]][1], split = "/")[[1]][1], split = "-")[[1]][1]]] <- sort(unique(c(Big_mem_color_values$list_values[["D"]][[strsplit(strsplit(strsplit(gene, split = "*", fixed = T)[[1]][1], split = "/")[[1]][1], split = "-")[[1]][1]]], gene)))
  }
}
Big_mem_color_values$start_calculating <- T
tmp_rows_cols <- AbSolution:::filter_merged(FBM = Big_mem_values$Big_DF, merged_df = Big_mem_values$Short_DF, merged_header = Big_mem_values$Header, use_rgermline = "Reconstructed germline" %in% input$use_what, use_repertoire = "Repertoire" %in% input$use_what, use_productive = "Productive" %in% input$use_productive_or_not, use_nonproductive = "Non-productive" %in% input$use_productive_or_not, my_regions = input$my_regions, my_var_elements = input$my_var_elements, my_vars = input$my_vars, my_vartypes = input$my_vartypes, use_sharedVDJ = input$use_sharedVDJ, V_J_to_use = input$VJ_included, groups = input$groups_selected, group_A = input$group_A, group_B = input$group_B, group_C = input$group_C, univlog = input$use_univlog, samples_to_keep = input$samples_selected, variables_to_remove = input$exclude_variables, pval_type = input$pval_type, pval_cutoff = input$pval_cutoff, estimate_cutoff = input$estimate_cutoff, number_selected_vars = input$number_selected_vars, VJ_deselected = input$VJ_deselected, VDJ_normalized_per_size = input$VDJ_normalized_per_size, R_mut_threshold_min = input$Rmut_filter[1], R_mut_threshold_max = input$Rmut_filter[2], to_compare_groups = input$work_as_categories, VDJ_maximize_clones = input$VDJ_maximize_clones, VDJ_normalized_per_sample = input$VDJ_normalized_per_sample, my_clone_def = input$my_clone_def, seed = input$seed, chains = input$chains_selected, igsubtypes = input$subtype_selected)
Exploration_values$rows <- tmp_rows_cols$ROWS
Exploration_values$columns <- tmp_rows_cols$COLUMNS
Selection_values$rows <- tmp_rows_cols$ROWS
Selection_values$columns <- tmp_rows_cols$COLUMNS
rm(tmp_rows_cols)
if (Big_mem_color_values$start_calculating) {
  suppressWarnings({
    Big_mem_color_values$V <- AbSolution:::Ab_palette(Big_mem_color_values$list_values[["V"]], vect_genes_comb = NA, type_values = c("V"), seed = input$seed, colorblind = input$colorblind_mode)
    Big_mem_color_values$J <- AbSolution:::Ab_palette(Big_mem_color_values$list_values[["J"]], vect_genes_comb = NA, type_values = c("J"), seed = input$seed, colorblind = input$colorblind_mode)
    Big_mem_color_values$VJ <- AbSolution:::Ab_palette(Big_mem_color_values$list_values[c("V", "J")], vect_genes_comb = sort(unique(Big_mem_values$Short_DF$V_and_J)), type_values = c("VJ"), seed = input$seed, colorblind = input$colorblind_mode)
    if ("Best_D" %in% colnames(Big_mem_values$Short_DF)) {
      Big_mem_color_values$D <- AbSolution:::Ab_palette(Big_mem_color_values$list_values[["D"]], vect_genes_comb = NA, type_values = c("D"), seed = input$seed, colorblind = input$colorblind_mode)
      Big_mem_color_values$VDJ <- AbSolution:::Ab_palette(Big_mem_color_values$list_values[c("V", "D", "J")], vect_genes_comb = sort(unique(Big_mem_values$Short_DF$V_and_D_and_J)), type_values = c("VDJ"), seed = input$seed, colorblind = input$colorblind_mode)
    }
  })
}
```



# Clonal exploration

User comments: `r (user_5_comments)`<br>


```{r clonal_explor, warning = FALSE, message = FALSE}
if (!is.null(Selection_values$rows) && length(Selection_values$rows) > 0 && !is.null(Selection_values$columns) && length(Selection_values$columns) > 0) {
  if (!(paste("Clone", input$clonal_level_group, input$clonal_region_group, input$new_clonal_group, input$identity_clonal_group, "simil", sep = "_") %in% colnames(Big_mem_values$Short_DF))) {
    Big_mem_values$Short_DF <- AbSolution:::calculate_clone(seq_df = Big_mem_values$Short_DF, clonotype = input$new_clonal_group, AA_or_NT = input$clonal_level_group, region = input$clonal_region_group, percentage = input$identity_clonal_group, calculate_shared_clones = input$calculate_shared_clones)
  }
}
if (!is.null(Selection_values$rows) && length(Selection_values$rows) > 0 && !is.null(Selection_values$columns) && length(Selection_values$columns) > 0 && !is.null(input$clonal_group) && input$clonal_group != "") {
  fig_violin <- AbSolution:::draw_violinplots(seq_df = Big_mem_values$Short_DF, group = "Patient_Sample", selected_rows = Selection_values$rows, clonotype = input$clonal_group, AA_or_NT = input$clonal_level_group, region = input$clonal_region_group, percentage = input$identity_clonal_group, freq_filter = input$filter_clonal_group, Selected_clones = ID_selected_values$clones, dominance_threshold = input$dominance_threshold)
  ID_selected_values$clones <- NULL
  print(ID_selected_values$clones$key)
  fig_violin
}
if (!is.null(Selection_values$rows) && length(Selection_values$rows) > 0 && !is.null(Selection_values$columns) && length(Selection_values$columns) > 0 && !is.null(input$clonal_group) && input$clonal_group != "") {
  fig_upset <- AbSolution:::draw_upsetplot(seq_df = Big_mem_values$Short_DF, group = "Patient_Sample", selected_rows = Selection_values$rows, clonotype = input$clonal_group, AA_or_NT = input$clonal_level_group, region = input$clonal_region_group, percentage = input$identity_clonal_group, freq_filter = input$filter_clonal_group, Selected_clones = ID_selected_values$clones)
  fig_upset %>%
    upsetjs::interactiveChart("click", events_nonce = TRUE) %>%
    upsetjs::generateDistinctIntersections()
}
if (!is.null(ID_selected_values$intersection_samples$setNames) && !is.null(ID_selected_values$intersection_samples$elems) && !is.null(Selection_values$rows) && length(Selection_values$rows) > 0 && !is.null(Selection_values$columns) && length(Selection_values$columns) > 0 && !is.null(input$clonal_group) && input$clonal_group != "") {
  if (length(unlist(ID_selected_values$intersection_samples$setNames)) > 1) {
    fig_sharedclones <- AbSolution:::draw_sharedclonesplot(seq_df = Big_mem_values$Short_DF, sets = ID_selected_values$intersection_samples$setNames, group = "Patient_Sample", selected_rows = Selection_values$rows, clonotype = input$clonal_group, AA_or_NT = input$clonal_level_group, region = input$clonal_region_group, percentage = input$identity_clonal_group, freq_filter = input$filter_clonal_group, Selected_clones = ID_selected_values$clones, dominance_threshold = input$dominance_threshold)
    ID_selected_values$clones <- event_data("plotly_selected")
    fig_sharedclones %>%
      toWebGL()
  }
}
```


# Sequence exploration

User comments: `r (user_3_comments)`<br>


```{r sequence_selection, warning = FALSE, message = FALSE}
if (!is.null(Exploration_values$rows) && length(Exploration_values$rows) > 0 && !is.null(Exploration_values$columns) && length(Exploration_values$columns) > 0) {
  if (is.null(input$plot_color_expl)) {
    selection <- "Group"
  } else {
    selection <- input$plot_color_expl
  }
  tmp_PCAex <- AbSolution:::big_PCA(FBM = Big_mem_values$Big_DF, rows = Exploration_values$rows, columns = Exploration_values$columns)
  tmp_PCAex[[1]] <- as.data.frame(tmp_PCAex[[1]])
  colnames(tmp_PCAex[[1]]) <- paste("Dim_", c(1:5), sep = "")
  tmp_PCAex[[1]]$Color <- as.factor(unlist(Big_mem_values$Short_DF[Exploration_values$rows, ..selection]))
  tmp_PCAex[[1]]$Text_ID <- Big_mem_values$Short_DF[Exploration_values$rows, get("Text_ID")]
  tmp_PCAex[[1]]$Seq_type <- factor(unlist(Big_mem_values$Short_DF[Exploration_values$rows, get("Sequence_type")]), levels = c("Reconstructed_germline", "Repertoire"))
  Exploration_values$Scores <- tmp_PCAex[[1]]
  Exploration_values$Variance_explained <- tmp_PCAex[[2]]
  if (input$use_UMAP && as.numeric(unname(strsplit(as.character(print(benchmarkme::get_ram(), unit_system = "iec")), split = " ")[[1]][1])) > round(length(Exploration_values$rows) * length(Exploration_values$columns) * 8 / 2^{
    20
  } / 1024, 2)) {
    print("UMAPEx")
    tmp_umap <- as.data.frame(umap(Big_mem_values$Big_DF[Exploration_values$rows, Exploration_values$columns])$layout)
    print(dim(tmp_umap))
    colnames(tmp_umap) <- paste("Dim_", c(1:2), sep = "")
    tmp_umap$Color <- as.factor(unlist(Big_mem_values$Short_DF[Exploration_values$rows, ..selection]))
    tmp_umap$Text_ID <- paste(unlist(Big_mem_values$Short_DF[Exploration_values$rows, get("ID")]), unlist(Big_mem_values$Short_DF[Exploration_values$rows, get("Sequence_type")]), sep = "_&_")
    tmp_umap$Seq_type <- factor(unlist(Big_mem_values$Short_DF[Exploration_values$rows, get("Sequence_type")]), levels = c("Reconstructed_germline", "Repertoire"))
    Exploration_values$UMAP <- tmp_umap
    if (shiny::isRunning()) {
      updateSelectInput(session, "Exploration_plot_type", choices = c(PCA = "PCA", UMAP = "UMAP"), selected = "PCA")
    }
    print("DONEUMAPEx")
    rm(tmp_umap)
  } else {
    if (shiny::isRunning()) {
      updateSelectInput(session, "Exploration_plot_type", choices = c(PCA = "PCA"), selected = "PCA")
    }
  }
  rm(tmp_PCAex)
  Big_mem_values$Run <- Big_mem_values$Run + 1
}
if (!is.null(Selection_values$rows) && length(Selection_values$rows) > 0 && !is.null(Selection_values$columns) && length(Selection_values$columns) > 0) {
  if (is.null(input$plot_color)) {
    selection <- "Group"
  } else {
    selection <- "Group"
  }
  tmp_PCA <- AbSolution:::big_PCA(FBM = Big_mem_values$Big_DF, rows = Selection_values$rows, columns = Selection_values$columns)
  tmp_PCA[[1]] <- as.data.frame(tmp_PCA[[1]])
  colnames(tmp_PCA[[1]]) <- paste("Dim_", c(1:5), sep = "")
  tmp_PCA[[1]]$Color <- as.factor(unlist(Big_mem_values$Short_DF[Selection_values$rows, ..selection]))
  tmp_PCA[[1]]$Text_ID <- Big_mem_values$Short_DF[Selection_values$rows, get("Text_ID")]
  tmp_PCA[[1]]$Seq_type <- factor(unlist(Big_mem_values$Short_DF[Selection_values$rows, get("Sequence_type")]), levels = c("Reconstructed_germline", "Repertoire"))
  Selection_values$Scores <- tmp_PCA[[1]]
  Selection_values$Variance_explained <- tmp_PCA[[2]]
  Big_mem_values$Run <- Big_mem_values$Run + 1
  if (input$use_UMAP == T && as.numeric(unname(strsplit(as.character(print(benchmarkme::get_ram(), unit_system = "iec")), split = " ")[[1]][1])) > round(length(Selection_values$rows) * length(Selection_values$columns) * 8 / 2^{
    20
  } / 1024, 2)) {
    print("UMAP")
    tmp_umap <- as.data.frame(umap(Big_mem_values$Big_DF[Selection_values$rows, Selection_values$columns])$layout)
    print(dim(tmp_umap))
    colnames(tmp_umap) <- paste("Dim_", c(1:2), sep = "")
    tmp_umap$Color <- as.factor(unlist(Big_mem_values$Short_DF[Selection_values$rows, ..selection]))
    tmp_umap$Text_ID <- paste(unlist(Big_mem_values$Short_DF[Selection_values$rows, get("ID")]), unlist(Big_mem_values$Short_DF[Selection_values$rows, get("Sequence_type")]), sep = "_&_")
    tmp_umap$Seq_type <- factor(unlist(Big_mem_values$Short_DF[Selection_values$rows, get("Sequence_type")]), levels = c("Reconstructed_germline", "Repertoire"))
    dim(tmp_umap)
    Selection_values$UMAP <- tmp_umap
    if (shiny::isRunning()) {
      updateSelectInput(session, "Selection_plot_type", choices = c(PCA = "PCA", UMAP = "UMAP"), selected = "PCA")
    }
    print("DONEUMAP")
  } else {
    if (shiny::isRunning()) {
      updateSelectInput(session, "Selection_plot_type", choices = c(PCA = "PCA"))
    }
  }
}
if (!is.null(input$plot_color_expl) && !is.null(input$plot_color)) {
  tmp_sp <- (unlist(Big_mem_values$Short_DF[Exploration_values$rows, get(input$plot_color_expl)]))
  if (input$plot_color_expl %in% c("Best_V", "Best_J")) {
    print(tmp_sp[1:10])
  } else if (input$plot_color_expl == "V_and_J") {
  }
  tmp_sp[which(is.na(tmp_sp))] <- "NotAvailable"
  tmp_sp[which((tmp_sp) == "  ")] <- "NotAvailable"
  tmp_sp[which((tmp_sp) == " ")] <- "NotAvailable"
  tmp_sp[which((tmp_sp) == "")] <- "NotAvailable"
  tmp_sp[which((tmp_sp) == "NotAvailable")] <- "NotAvailable"
  tmp_sp <- unname(tmp_sp)
  Exploration_values$Scores$Color <- tmp_sp
  if (as.numeric(unname(strsplit(as.character(print(benchmarkme::get_ram(), unit_system = "iec")), split = " ")[[1]][1])) > round(length(Exploration_values$rows) * length(Exploration_values$columns) * 8 / 2^{
    20
  } / 1024, 2)) {
    Exploration_values$UMAP$Color <- tmp_sp
  }
  old_sp <- NULL
  all_sp <- NULL
  if (!is.null(ID_selected_values$subclones)) {
    old_sp <- tmp_sp
    tmp_sp[Exploration_values$Scores$Text_ID %in% ID_selected_values$subclones$key] <- "User selected"
    counterpart_start <- paste(sapply(ID_selected_values$subclones$key, function(z) strsplit(z, split = "_&_")[[1]][1]), "_&_", sep = "")
    tmp_txt_id <- paste(sapply(Exploration_values$Scores$Text_ID, function(z) strsplit(z, split = "_&_")[[1]][1]), "_&_", sep = "")
    tmp_sp[intersect(which(tmp_txt_id %in% counterpart_start), which(tmp_sp != "User selected"))] <- "Counterpart"
  }
  tmp_sp <- unname(tmp_sp)
  Exploration_values$Scores$Selected <- tmp_sp
  if (as.numeric(unname(strsplit(as.character(print(benchmarkme::get_ram(), unit_system = "iec")), split = " ")[[1]][1])) > round(length(Exploration_values$rows) * length(Exploration_values$columns) * 8 / 2^{
    20
  } / 1024, 2)) {
    Exploration_values$UMAP$Selected <- tmp_sp
  }
  if (shiny::isRunning()) {
    print(all(Exploration_values$Scores$Color == Exploration_values$Scores$Selected))
    print(ID_selected_values$subclones$key)
    print(Exploration_values$Scores$Text_ID[which(Exploration_values$Scores$Text_ID %in% ID_selected_values$subclones$key)])
    print(old_sp[which(Exploration_values$Scores$Text_ID %in% ID_selected_values$subclones$key)])
    print(tmp_sp[which(Exploration_values$Scores$Text_ID %in% ID_selected_values$subclones$key)])
  }
  tmp_sp <- (unlist(Big_mem_values$Short_DF[Selection_values$rows, get(input$plot_color)]))
  tmp_sp[which(is.na(tmp_sp))] <- "Not specified"
  tmp_sp[which((tmp_sp) == "  ")] <- "Not specified"
  tmp_sp[which((tmp_sp) == " ")] <- "Not specified"
  tmp_sp[which((tmp_sp) == "")] <- "Not specified"
  tmp_sp[which((tmp_sp) == "NotAvailable")] <- "Not specified"
  Selection_values$Scores$Color <- tmp_sp
  if (as.numeric(unname(strsplit(as.character(print(benchmarkme::get_ram(), unit_system = "iec")), split = " ")[[1]][1])) > round(length(Selection_values$rows) * length(Selection_values$columns) * 8 / 2^{
    20
  } / 1024, 2)) {
    Selection_values$UMAP$Color <- tmp_sp
  }
  if (!is.null(ID_selected_values$subclones)) {
    tmp_sp[Selection_values$Scores$Text_ID %in% ID_selected_values$subclones$key] <- "User selected"
    all_sp <- rep("Non-selected", nrow(Big_mem_values$Short_DF))
    all_sp[Big_mem_values$Short_DF$Text_ID %in% ID_selected_values$subclones$key] <- "User selected"
    counterpart_start <- paste(sapply(ID_selected_values$subclones$key, function(z) strsplit(z, split = "_&_")[[1]][1]), "_&_", sep = "")
    tmp_txt_id <- paste(sapply(Selection_values$Scores$Text_ID, function(z) strsplit(z, split = "_&_")[[1]][1]), "_&_", sep = "")
    tmp_sp[intersect(which(tmp_txt_id %in% counterpart_start), which(tmp_sp != "User selected"))] <- "Counterpart"
  }
  all_sp <- unname(all_sp)
  Big_mem_values$Short_DF$Selected <- all_sp
  if (!is.null(ID_selected_values$clones)) {
    print("Wow clones working")
    if (input$clonal_group == "Clone_ID") {
      clonepart_start <- (Big_mem_values$Short_DF)[intersect(Selection_values$rows, which((Big_mem_values$Short_DF)[, get("Clone_ID")] %in% ID_selected_values$clones$key)), get("ID")]
    } else {
      clonepart_start <- (Big_mem_values$Short_DF)[intersect(Selection_values$rows, which((Big_mem_values$Short_DF)[, get(paste("Clone", input$clonal_level_group, input$clonal_region_group, input$clonal_group, input$identity_clonal_group, "simil", sep = "_"))] %in% ID_selected_values$clones$key)), get("ID")]
    }
    tmp_txt_id <- sapply(Selection_values$Scores$Text_ID, function(z) strsplit(z, split = "_&_")[[1]][1])
    tmp_sp[which(tmp_txt_id %in% clonepart_start)] <- "Clones"
  }
  Selection_values$Scores$Selected <- tmp_sp
  if (as.numeric(unname(strsplit(as.character(print(benchmarkme::get_ram(), unit_system = "iec")), split = " ")[[1]][1])) > round(length(Selection_values$rows) * length(Selection_values$columns) * 8 / 2^{
    20
  } / 1024, 2)) {
    Selection_values$UMAP$Selected <- tmp_sp
  }
}
if (!is.null(Selection_values$rows) && length(Selection_values$rows) > 0 && !is.null(Selection_values$columns) && length(Selection_values$columns) > 0) {
  if (input$plot_color == "Best_V") {
    Sel_colors <- Big_mem_color_values$V
  } else if (input$plot_color == "Best_J") {
    Sel_colors <- Big_mem_color_values$J
  } else if (input$plot_color == "Best_D") {
    Sel_colors <- Big_mem_color_values$D
  } else if (input$plot_color == "V_and_D_and_J") {
    Sel_colors <- Big_mem_color_values$VDJ
  } else if (input$plot_color == "V_and_J") {
    Sel_colors <- Big_mem_color_values$VJ
  } else {
    Sel_colors <- AbSolution:::Ab_palette(list_values = unique(Selection_values$Scores$Color), vect_genes_comb = NA, type_values = "cualitative", colorblind = input$colorblind_mode, seed = input$seed)
    names(Sel_colors) <- sort(unique(Selection_values$Scores$Color))
  }
  Sel_colors_BORDER <- c(Sel_colors, "#050609", "#ff4d6d", "#FFAD05")
  names(Sel_colors_BORDER) <- c(names(Sel_colors), "User selected", "Counterpart", "Clones")
  Sel_colors_BORDER_width <- c(rep(1, length(Sel_colors)), 4, 4, 4)
  names(Sel_colors_BORDER_width) <- c(names(Sel_colors), "User selected", "Counterpart", "Clones")
  Sel_colors_BORDER_symbol <- c("circle", "star-diamond")
  names(Sel_colors_BORDER_symbol) <- c("Repertoire", "Reconstructed_germline")
  if (input$Selection_plot_type == "PCA") {
    test <- Selection_values$Scores
  } else if (input$Selection_plot_type == "UMAP") {
    test <- Selection_values$UMAP
  }
  test$Colors <- Sel_colors[match(test$Color, names(Sel_colors))]
  test$Color_border <- Sel_colors_BORDER[match(test$Selected, names(Sel_colors_BORDER))]
  test$Width_border <- Sel_colors_BORDER_width[match(test$Selected, names(Sel_colors_BORDER_width))]
  test$Symbol <- Sel_colors_BORDER_symbol[match(test$Seq_type, names(Sel_colors_BORDER_symbol))]
  if (length(input$Selection_plot_type_dim) < 2) {
    dim1 <- 1
    dim2 <- 2
  } else {
    dim1 <- as.numeric(input$Selection_plot_type_dim[1])
    dim2 <- as.numeric(input$Selection_plot_type_dim[2])
  }
  tmpDim_1 <- test[, which(colnames(test) == paste0("Dim_", dim1))]
  tmpDim_2 <- test[, which(colnames(test) == paste0("Dim_", dim2))]
  test$Dim_1 <- tmpDim_1
  test$Dim_2 <- tmpDim_2
  fig <- plot_ly(data = test, type = "scatter", mode = "markers", colors = Sel_colors) %>%
    config(toImageButtonOptions = list(format = "svg", filename = paste("PCA_Selection_plot", Sys.time(), sep = "_"), width = 1400, height = 1000, scale = 4))
  test <- test[(order(test$Color)), ]
  tmp_test_ns <- test[intersect(intersect(which(test$Selected != "Clones"), which(test$Selected != "User selected")), which(test$Selected != "Counterpart")), ]
  fig <- fig %>%
    add_trace(data = tmp_test_ns, x = ~Dim_1, y = ~Dim_2, opacity = 0.7, text = ~Text_ID, key = ~Text_ID, color = ~Color, colors = Sel_colors, type = "scatter", mode = "markers", fill = ~"", hovertemplate = paste("<b>%{text}</b>"), marker = list(sizemode = "diameter"), name = tmp_test_ns$Color, legendgroup = tmp_test_ns$Color)
  tmp_test <- test[which(test$Selected == "Counterpart"), ]
  if (nrow(tmp_test) > 0) {
    fig <- fig %>%
      add_trace(data = tmp_test, x = ~Dim_1, y = ~Dim_2, opacity = 0.7, text = ~Text_ID, key = ~Text_ID, color = ~Color, colors = Sel_colors, symbol = ~Symbol, type = "scatter", mode = "markers", fill = ~"", hovertemplate = paste("<b>%{text}</b>"), marker = list(line = list(color = "#ff4d6d", width = tmp_test$Width_border[1])), name = tmp_test$Color, showlegend = FALSE, legendgroup = tmp_test$Color)
  }
  tmp_test <- test[which(test$Selected == "Clones"), ]
  if (nrow(tmp_test) > 0) {
    not_in_leg <- which(unique(tmp_test$Color) %!in% unique(tmp_test_ns$Color))
    if (length(not_in_leg) > 0) {
      tmp_tmp_test <- tmp_test[which(tmp_test$Color %in% not_in_leg), ]
      fig <- fig %>%
        add_trace(data = tmp_tmp_test, x = ~x, y = ~y, opacity = 0.9, text = ~Text_ID, key = ~Text_ID, color = ~Color, symbol = ~Symbol, type = "scatter", mode = "markers", fill = ~"", hovertemplate = paste("<b>%{text}</b>"), marker = list(line = list(color = "black", width = tmp_tmp_test$Width_border[1])), name = tmp_tmp_test$Color, showlegend = TRUE, legendgroup = tmp_tmp_test$Color)
    }
    tmp_tmp_test <- tmp_test[which(tmp_test$Color %!in% not_in_leg), ]
    if (nrow(tmp_tmp_test) > 0) {
      fig <- fig %>%
        add_trace(data = tmp_tmp_test, x = ~x, y = ~y, opacity = 0.9, text = ~Text_ID, key = ~Text_ID, color = ~Color, symbol = ~Symbol, type = "scatter", mode = "markers", fill = ~"", hovertemplate = paste("<b>%{text}</b>"), marker = list(line = list(color = "black", width = tmp_tmp_test$Width_border[1])), name = tmp_tmp_test$Color, showlegend = FALSE, legendgroup = tmp_tmp_test$Color)
    }
  }
  tmp_test <- test[which(test$Selected == "User selected"), ]
  if (nrow(tmp_test) > 0) {
    not_in_leg <- which(unique(tmp_test$Color) %!in% unique(tmp_test_ns$Color))
    if (length(not_in_leg) > 0) {
      tmp_tmp_test <- tmp_test[which(tmp_test$Color %in% not_in_leg), ]
      fig <- fig %>%
        add_trace(data = tmp_tmp_test, x = ~x, y = ~y, opacity = 0.9, text = ~Text_ID, key = ~Text_ID, color = ~Color, symbol = ~Symbol, type = "scatter", mode = "markers", fill = ~"", hovertemplate = paste("<b>%{text}</b>"), marker = list(line = list(color = "black", width = tmp_tmp_test$Width_border[1])), name = tmp_tmp_test$Color, showlegend = TRUE, legendgroup = tmp_tmp_test$Color)
    }
    tmp_tmp_test <- tmp_test[which(tmp_test$Color %!in% not_in_leg), ]
    if (nrow(tmp_tmp_test) > 0) {
      fig <- fig %>%
        add_trace(data = tmp_tmp_test, x = ~x, y = ~y, opacity = 0.9, text = ~Text_ID, key = ~Text_ID, color = ~Color, symbol = ~Symbol, type = "scatter", mode = "markers", fill = ~"", hovertemplate = paste("<b>%{text}</b>"), marker = list(line = list(color = "black", width = tmp_tmp_test$Width_border[1])), name = tmp_tmp_test$Color, showlegend = FALSE, legendgroup = tmp_tmp_test$Color)
    }
  }
  fig <- fig %>%
    layout(title = "Selection plot", plot_bgcolor = "#e5ecf6", legend = list(orientation = "v", y = 0), showlegend = T, xaxis = list(title = if (input$Selection_plot_type == "PCA") {
      paste("Dim ", dim1, " (", 100 * Selection_values$Variance_explained[dim1], "%)", sep = "")
    } else if (input$Selection_plot_type == "UMAP") {
      "Dim  1"
    }), yaxis = list(title = if (input$Selection_plot_type == "PCA") {
      paste("Dim ", dim2, " (", 100 * Selection_values$Variance_explained[dim2], "%)", sep = "")
    } else if (input$Selection_plot_type == "UMAP") {
      "Dim 2"
    }, dragmode = "lasso")) %>%
    config(displaylogo = FALSE, modeBarButtonsToRemove = c("zoomIn2d", "zoomOut2d", "autoScale2d", "pan2d", "hoverCompareCartesian"))
  if (shiny::isRunning()) {
    ID_selected_values$subclones <- event_data("plotly_selected")
  }
  fig %>%
    toWebGL()
}
```


# Feature exploration

User comments: `r (user_4_comments)`<br>

```{r feature, warning = FALSE, message = FALSE}
if (!is.null(Selection_values$rows) && length(Selection_values$rows) > 0 && !is.null(Selection_values$columns) && length(Selection_values$columns) > 0) {
  fig_violin <- AbSolution:::draw_feature_violinplot(values = Big_mem_values$Big_DF[, which(Big_mem_values$Header == input$plot_feature)], name_values = input$plot_feature, sequence_info_df = Big_mem_values$Short_DF, group_info = input$groups_selected, additional_group_info = input$plot_color_feature, show_reconstructed = input$show_reconstructed, selected_rows = Selection_values$rows, selected_subclones = NULL, hide_dots = input$hide_points)
  ID_selected_values$subclones <- NULL
  print(ID_selected_values$clones$key)
  fig_violin
}
```

# Citation
## AbSolution
## ENCORE
> *van Kampen AHC, Mahamune U, Jongejan A, van Schaik BDC, Balashova D, Lashgari D, Pras-Raves M, Wever EJM, Dane AD, García-Valiente R, Moerland PD. ENCORE: a practical implementation to improve reproducibility and transparency of computational research. Nat Commun. 2024 Sep 16;15(1):8117. doi: 10.1038/s41467-024-52446-8. PMID: 39284801; PMCID: PMC11405857.*

# System and version information

## System information
```{r system_info, warning = FALSE, message = FALSE}
          osVersion
          Sys.info()[which(names(Sys.info()) %in% c("sysname", "release", "version", "machine"))]
          print(benchmarkme::get_ram(), unit_system = "iec")
          benchmarkme::get_cpu()
```

## R information
```{r r_info, warning = FALSE, message = FALSE}
          sessionInfo()

```


<br><br><br><br>

![](data:image/png;base64,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)





<link rel="icon" type="image/png" sizes="16x16" href="data:image/png;base64,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" />
<link rel="shortcut icon" type="image/png" sizes="16x16" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALAAAAChCAMAAABQ48VSAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAABjUExURQAAAAAAAABAQBwcOSAwMB8pMyMrMiQvNCAsMCMtMyEuMSItMSItMiMuMiIsMyIsMiItMj1HS1dfY211eIGIipOYm6GmqK+ztbu/wMXIyc7R0tfZ2t/h4efo6O/v8Pb39////7lYbT8AAAAQdFJOUwABBAkQGSQxQFBjeI+ow+DwsjCpAAAACXBIWXMAABcRAAAXEQHKJvM/AAAGFklEQVR4Xu2c6XbiMAxGoet0uhCmy3Shy/s/5QQQWHZs6fMac87cXzS45ZImQp+dsPgPcXVLD06E69VwQw9Pguth5ISMd77DcE0/ds+vve8wXNGGzrkh3ZFTMF7+Jtkd/RvbvsNwQdt7ZXlLokf6Np769m3s8x1W5/RsfyzvydGmW+OzBzJ06dT4POQ7Gi9pTE8IvsPw0J/x+Yrc/Nz3Zqz4jsY0sBMuNN9huKOhXXCl+3ZlPMYLhG6MQd9ujCleIHQRmiJ8h+EX/dKMHOMQxuwxz2nXdeaNIG68QJjT2Nv+qsxnnOY7XwRJ9Z3LON13GOZo6ANxCGOGCBKMQxjNjcV4gdDYONu3cWhS4wVCQ2MgXiA0C02FfJsZQ3EIo0lDD8cLhAbGRX0bGEfFC4TKq3mR8QKhasxjqy3lqBfzUuIFQq2YV8u3VgTJaX81ahgn+j79HNnQJh+X9CrlSN2/oHDx0LS8oz8cCypc2Dg9XsDCRRv6jHYdFi5pHPbdkMuOD9pogQuXMw7Hiz+kQqxpMydCeFid0SvmIcShN1Ih/tJmToxwmdAkxYsvUiE+aTMnSrjE2til4PtMJkce6QlGnHB+aBLb9Q8yOfJGTzAihXMbetF3TSKGb3qGESucZyzHi78kwnimpwzRwjnGShxyTrkt01IcL5xurMShR/KwmJTiBOHU0KS16+/kYTEpxSnCScZqvFh/k4fFpBQnCSeEJj0OvZCGg1uK04SjIwjQrlt9j8EtxYnCkcaAL+97PtjR4ZZiR3j98rbZjv7avHo+Fjkxxkgc4n3PCz//nFJsC7/Swx1fLzTGDx5BoNUWetEpTinmwutPenTgU9zLqDEUhyZ9j8EuxUz40/UdEXcy1tBjcWjS9xjsUsyEvUjGUATBfKd9j+GLxuzRhHONwdUWT99jsA5MVfjniUb6UI3R1QtP32N4p0E7dOEvXxQ8oFwCifp6+54jVinWhX9eaagXMebBqy3evsfAD0tHePM87s8n+/c9bT9DCE2wr7/vMfBSbAsf3sqj9RembT8nbLxE53cCfY/hDw0csYTNrreMrYN+SrihPwN3caDvMbBSzIV5Y8TftF0Ip4SNsaLmzPd4YAZc2CoHvNDQpiCCMY0QceZ7fJhSzITt9pL3QUrjJq2NIcZiEd5jjkombJcvvuulz4494dB0QSPCCH3PEVOpCgkLoUk1Fvoew7EeFBJeCYsgirHU9xiOpZh5ZRzDck9xRaP8iH2P4VCK+Y5MrhIPysSxOOMDnHJbDqWYC4fqsG+alnOvTnQLcz5y32M4lGIunPhJp/tKsz5K32OgE8kSTusloEnukLHW9xhot9nC3m5N/mS+AyflA8ZW32P+wwRvMr73p5gj7GPyZzio72LhX/q0lGibwfN2dGHxlPsN+/qNrb5nukBgHTD7sqsLS0X4JsLXa2z1PZ5Xsg7OXSlWhaUDIs7XNwPEi7CyyEUfxWyLbyJF9iURmImx1fd4X4q/o93Zz4SnU1U/31JFS7gWyDXmfQ9VAQfrmNmWYi48rJ3GacOy1ISkK4GWVgSx+h7/x5N1Vm6HWMLj/4j9Cz6l3btKvKoGjXk4z+/bA0ObH071heeuCiO1vxpQzCtMji8SmkqT59veONe3tfEDNvEu0tIYadd1il81HKSMb5Xrhr2Uu7+8ypXDE0reD68uPhcAjxcI9Y1vi/rWN45s1wFSr3DFKO9b17jOzQY5NynK1PHNu61SotqtEZWMK97/XsM4PV4glA9NdX3LG+e3vxplQ1N937LGLXxLNvTFLtRXKGWsrbaUo4xxqXiBcEmvmUNL3xIxr/XXbeXGvLLxAiEv5rX3zYsgMast5Ug3rhEvEBJvY5zNNzU0VYoXECnGc/qmNPQzfyFYtHHldl0nzrh2vECAL4EcadP+auChqQ9ffG2sF180NPXjizX0reIQhm7cLg5haMZt4wWCbNyfrxyaWschjLDxHPECIRSaevUNRZB54hCGz3i+eIEwNZ61XQdwI0jvvq5xB983rMIb+oqrLeUwEaSHeIFwMD4V34NxT+2vxvYSyFPy3ca80/IdQ9M834n8n2wWi39w7psVEngSKAAAAABJRU5ErkJggg==" />
